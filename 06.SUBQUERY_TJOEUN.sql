/*
  - SUBQUERY
    하나의 SQL에 포함된 또 다른 SQL
    
    MAIN SQL의 보조 역할
*/
-- 김정보와 같은 부서의 사원
SELECT EMP_NAME
FROM EMPLOYEE
WHERE DEPT_CODE = (
  SELECT DEPT_CODE
  FROM EMPLOYEE
  WHERE EMP_NAME = '김정보'
);

SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (
  SELECT CEIL(AVG(SALARY))
  FROM EMPLOYEE
);

--------------------------------------------------------------------
/*
  - 단일 행 서브쿼리 : 서브쿼리의 조회 결과값이 1개일 때 (1행 1열)
  - 다중 행 서브쿼리 : 서브쿼리의 조회 결과값이 여러 행일 때 (다중행 1열)
  - 다중 열 서브쿼리 : 서브쿼리의 조회 결과값이 1행 여러 열일 때(1행 다중열)
  - 다중 행 다중 열 서브쿼리 : 서브쿼리의 조회 결과값이 여러 행 여러 열일 때(다중행 다중열)
    >> 서브쿼리의 종류에 따라 연산자가 달라짐
*/

/* 
  단일 행 서브쿼리 : 일반 비교연산자 사용 가능
*/
SELECT EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY < (
  SELECT CEIL(AVG(SALARY))
  FROM EMPLOYEE
);

SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE SALARY = (
  SELECT MIN(SALARY)
  FROM EMPLOYEE
);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (
  SELECT SALARY
  FROM EMPLOYEE
  WHERE EMP_NAME = '박정보'
);

SELECT EMP_ID, EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_CODE = D.DEPT_ID
  AND SALARY > (
  SELECT SALARY
  FROM EMPLOYEE
  WHERE EMP_NAME = '박정보'
);

SELECT EMP_ID, EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE E
  LEFT JOIN DEPARTMENT D
    ON E.DEPT_CODE = D.DEPT_ID
WHERE SALARY > (
  SELECT SALARY
  FROM EMPLOYEE
  WHERE EMP_NAME = '박정보'
);

SELECT EMP_ID, EMP_NAME, PHONE, HIRE_DATE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID
  AND DEPT_CODE = (
    SELECT DEPT_CODE
    FROM EMPLOYEE
    WHERE EMP_NAME = '왕정보')
  AND EMP_NAME <> '왕정보';
  
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = (
  SELECT MAX(SUM(SALARY))
  FROM EMPLOYEE
  GROUP BY DEPT_CODE
);

/* 
  다중 행 서브쿼리
    - 여러개의 결과값 중에서 한개라도 일치하는 값이 있다면 반환
      > ANY 서브쿼리 : 여러개의 결과값 중에서 "한개라도" 클 경우
      < ANY 서브쿼리 : 여러개의 결과값 중에서 "한개라도" 작을 경우
      
      비교대상 > ANY(값1, 값2, 값3)
      
      비교대상 < ANY(값1, 값2, 값3)
*/
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE JOB_CODE IN (
  SELECT JOB_CODE
  FROM EMPLOYEE
  WHERE EMP_NAME IN ('조정연','전지연')
);

---------------------------------------------------------------------------------
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
  JOIN JOB J
    USING(JOB_CODE)
WHERE JOB_CODE = 'J6'
  AND SALARY > (
    SELECT MIN(SALARY)
    FROM EMPLOYEE E
      JOIN JOB J
        ON E.JOB_CODE = J.JOB_CODE
    WHERE J.JOB_NAME = '과장'
);

SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E
  JOIN JOB J
    USING(JOB_CODE)
WHERE JOB_CODE = 'J6'
  AND SALARY > ANY(
    SELECT SALARY
    FROM EMPLOYEE E
      JOIN JOB J
        ON E.JOB_CODE = J.JOB_CODE
    WHERE J.JOB_NAME = '과장'
);

/* 
  다중 열 서브쿼리
    - 결과값이 단일행이고 컬럼 수가 여러개일 때
*/
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '장정보')
  AND JOB_CODE = (SELECT JOB_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '장정보');

-- 다중열 쿼리로 전환
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) = (SELECT DEPT_CODE, JOB_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '장정보');
                    
-- 지정보 사원과 같은 직급코드, 사수를 가지고 있는 사원들의 사번, 사원명, 직급코드, 사수번호
SELECT EMP_ID, EMP_NAME, JOB_CODE, MANAGER_ID
FROM EMPLOYEE
WHERE (JOB_CODE, MANAGER_ID) = (SELECT JOB_CODE, MANAGER_ID
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '지정보');
                    

/* 
  다중 행, 다중 열 서브쿼리
    - 결과값이 다중 행이고 컬럼 수가 여러개일 때
*/
-- 각 직급코드별 최저 급여 사원 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE (JOB_CODE, SALARY) IN (SELECT JOB_CODE, MIN(SALARY)
                              FROM EMPLOYEE
                              GROUP BY JOB_CODE);

-- 각 부서별 최고 급여 사원 조회
SELECT EMP_ID, EMP_NAME, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE (DEPT_CODE, SALARY) IN (SELECT DEPT_CODE, MAX(SALARY)
                              FROM EMPLOYEE
                              GROUP BY DEPT_CODE);


--========================================================================================================
-- INLINE VIEW
/*
  - 인라인 뷰
    : 서브쿼리를 수행한 결과를 마치 테이블처럼 사용
    * TOP-N 분석
*/
SELECT T.*
FROM (
  SELECT EMP_ID, EMP_NAME, (SALARY * NVL(1 + BONUS, 1)* 12) AS "BONUS_YEAR_SALARY", DEPT_CODE
  FROM EMPLOYEE) T
WHERE BONUS_YEAR_SALARY > 30000000;

-- TOP-N, ROWNUM
SELECT ROWNUM, E.*
FROM EMPLOYEE E;

SELECT ROWNUM, T.*
FROM (SELECT EMP_ID, EMP_NAME, SALARY
      FROM EMPLOYEE
      ORDER BY SALARY DESC) T;
      
-- 가장 최근에 입사한 사원 5명
SELECT ROWNUM, T.*
FROM (SELECT EMP_NAME, SALARY, HIRE_DATE
      FROM EMPLOYEE
      ORDER BY HIRE_DATE DESC) T
WHERE ROWNUM <= 5;

-- 각 부서별 평균급여가 높은 3개 부서의 부서코드 평균급여
SELECT T.*
FROM (SELECT DEPT_CODE, CEIL(SUM(SALARY) / COUNT(*)) AVGSAL
      FROM EMPLOYEE
      GROUP BY DEPT_CODE
      ORDER BY AVGSAL DESC) T
WHERE ROWNUM <= 3;


-- INLINE VIEW
/*
  - WITH
    : 서브쿼리에 이름을 붙여주고 인라인 뷰로 사용시 서브쿼리의 이름으로 FROM절에 기술
      * 장점
        같은 서브쿼리가 여러번 사용될 경우 중복으로 작성하지 않아도 된다
        실행 속도가 빨라진다
*/
WITH TOP_N_SAL AS (SELECT DEPT_CODE, CEIL(SUM(SALARY) / COUNT(*)) AVGSAL
      FROM EMPLOYEE
      GROUP BY DEPT_CODE
      ORDER BY AVGSAL DESC)
SELECT T.* 
FROM TOP_N_SAL T
WHERE ROWNUM <= 3;
-- Query 시 세미콜론이 붙어있으면 해당 쿼리의 끝을 의미하기에 아래에서 해당 테이블을 사용 불가
-- 즉 union, minus 등 여러개의 테이블을 연산할 때 사용함

/*
  - 순위 매기는 함수
    : RANK() OVER(정렬 기준) | DENSE_RANK() OVER(정렬기준)
      > RANK OVER : 동일한 순위 이후의 등수를 공동으로 계산하여 순위 반환 (1, 2, [2, 2], 5)
      > DENSE_RNAK OVER : 동일한 순위 이후의 등수를 무조건 1씩 증가시켜 반환 (1, 2, [2, 2], 3)
*/
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) AS RANK
FROM EMPLOYEE;

-- 급여가 상위 5등 안에 드는 사원 수
SELECT T.* 
FROM(
  SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS RANK
  FROM EMPLOYEE
) T
WHERE RANK <= 5;
--> WITH와 같이 사용
WITH RANKING AS (SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS RANK
                  FROM EMPLOYEE)
SELECT R.* FROM RANKING R
WHERE RANK <= 5;


-----------------------------------------------------연습문제------------------------------------------------
-- 1.
SELECT TO_CHAR(TO_DATE('2020-12-25', 'YYYY-MM-DD'), 'DAY') 요일 FROM DUAL;
-- 2.
SELECT EMP_NAME, EMP_NO, JOB_CODE
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = '2'
  AND EMP_NO LIKE '7_%'
  AND EMP_NAME LIKE '전%';
-- 3.
SELECT EMP_ID, EMP_NAME, 
  (TO_NUMBER(EXTRACT(YEAR FROM SYSDATE)) -  TO_NUMBER(EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 6), 'RR/MM/DD')))) AS AGE, 
  DEPT_TITLE, JOB_NAME
FROM EMPLOYEE E, DEPARTMENT D, JOB J
WHERE E.DEPT_CODE = D.DEPT_ID
  AND E.JOB_CODE = J.JOB_CODE
  AND TO_NUMBER(EXTRACT(YEAR FROM SYSDATE)) - 
  TO_NUMBER(EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 6), 'RR/MM/DD'))) = (SELECT MIN(TO_NUMBER(EXTRACT(YEAR FROM SYSDATE)) - 
  TO_NUMBER(EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO, 1, 6), 'RR/MM/DD')))) FROM EMPLOYEE);
-- 4.
SELECT EMP_ID, EMP_NAME, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE
  AND EMP_NAME LIKE '%하%';
-- 5.
SELECT EMP_NAME, JOB_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE E, JOB J, DEPARTMENT
WHERE E.JOB_CODE = J.JOB_CODE
  AND E.DEPT_CODE = DEPT_ID
  AND E.DEPT_CODE IN ('D5', 'D6');
-- 6.
SELECT EMP_NAME, BONUS, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID
  AND LOCATION_ID = LOCAL_CODE
  AND BONUS IS NOT NULL;
-- 7.
SELECT EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
WHERE E.JOB_CODE = J.JOB_CODE(+)
  AND E.DEPT_CODE = D.DEPT_ID(+)
  AND D.LOCATION_ID = L.LOCAL_CODE(+);
-- 8.
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE E, DEPARTMENT D, LOCATION L, NATIONAL N
WHERE E.DEPT_CODE = D.DEPT_ID(+)
  AND D.LOCATION_ID = L.LOCAL_CODE(+)
  AND L.NATIONAL_CODE = N.NATIONAL_CODE(+)
  AND NATIONAL_NAME IN ('한국', '일본');
-- 9.
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE 
                  FROM EMPLOYEE 
                  WHERE EMP_NAME = '하정연');
-- 10.
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE
  AND BONUS IS NULL
  AND E.JOB_CODE IN ('J4', 'J7');
-- 11.
SELECT COUNT(CASE WHEN ENT_YN = 'N' THEN 1 END) "NOT_ENTIRE", COUNT(CASE WHEN ENT_YN = 'Y' THEN 1 END) "ENTIRE"
FROM EMPLOYEE;
-- 12.
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, HIRE_DATE, RANK
FROM (SELECT E.*, RANK() OVER(ORDER BY (SALARY * NVL(1+BONUS, 1) * 12) DESC) AS RANK FROM EMPLOYEE E) T, JOB J, DEPARTMENT
WHERE T.JOB_CODE = J.JOB_CODE
  AND T.DEPT_CODE = DEPT_ID
  AND RANK <= 5
ORDER BY RANK ASC;
-- 13.
  -- 13-1. HAVING
SELECT DEPT_TITLE, SUM(SALARY) DEPT_SAL
FROM DEPARTMENT, EMPLOYEE
WHERE DEPT_ID = DEPT_CODE(+)
GROUP BY DEPT_TITLE
HAVING SUM(SALARY) >= (SELECT SUM(SALARY)/5 FROM EMPLOYEE);
  -- 13-2. INLINE VIEW
SELECT DEPT_TITLE, DEPT_SAL
FROM (SELECT DEPT_TITLE, SUM(SALARY) DEPT_SAL
      FROM DEPARTMENT, EMPLOYEE
      WHERE DEPT_ID = DEPT_CODE(+)
      GROUP BY DEPT_TITLE)
WHERE DEPT_SAL >= (SELECT SUM(SALARY)/5 FROM EMPLOYEE);
  -- 13-3. WITH
WITH DEPT_TOT AS (SELECT DEPT_TITLE, SUM(SALARY) DEPT_SAL
      FROM DEPARTMENT, EMPLOYEE
      WHERE DEPT_ID = DEPT_CODE(+)
      GROUP BY DEPT_TITLE)
SELECT * FROM DEPT_TOT
WHERE DEPT_SAL >= (SELECT SUM(SALARY)/5 FROM EMPLOYEE);
-- 14.
SELECT DEPT_TITLE, SUM(SALARY) DEPT_SAL
FROM DEPARTMENT, EMPLOYEE
WHERE DEPT_ID(+) = DEPT_CODE
GROUP BY DEPT_TITLE;
-- 15.
WITH ALL_SAL AS (SELECT SALARY FROM EMPLOYEE)
SELECT SUM(SALARY) AS SAL_SUM, CEIL(SUM(SALARY)/COUNT(*)) AS SAL_AVG FROM ALL_SAL;