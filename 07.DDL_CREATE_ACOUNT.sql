/*
  DDL: 데이터 정의 언어
    오라클에서 제공하는 객체를 만들고(CREATE)
    구조를 변경하거나(ALTER)
    구조를 삭제하는(DROP) 언어
    즉, 실제 데이터 값이 아닌 구조 자체를 정의하는 언어
    
    - 오라클에서 객체(구조): 테이블(TABLE), 뷰(VIEW), 시퀀스(SEQUENCE), 인덱스(INDEX), 패키지(PACKAGE)
                          트리거(TRIGGER), 프로시저(PROCEDURE), 함수(FUNCTION), 동의어(SYNONYM), 사용자(USER)
*/
--=========================================================================================================
/*
  CREATE : 객체를 생성하는 예약어 
*/
------------------------------------  
/*
  테이블 생성
    - TABLE이란? 행(ROW)과 열(COLUMN)으로 구성되는 가장 기본적인 데이터베이스 객체 
                모든 데이터들은 테이블을 통해 저장됨    
                (표 형태를 DB에서는 TABLE으로 지칭)  
                                                
    [FORMAT]
      CREATE TABLE [TABLE_NAME] (     
        COLUMN_NAME DATA_TYPE(SIZE),  
        ... (NEEDED AS YOU WANT)      
      );
      
      DATA TYPES:
        - CHARACTER : CHAR(SIZE[AS BYTE])|VARCHAR2(SIZE[AS BYTE])               
          > CHAR : MAXIMUM 2000 BYTE, NON-FLEXIBLE SIZE, NON-FLEXIBLE DATA USED 
          > VARCHAR2 : MAXIMUM 4000 BYTE, FLEXIBLE SIZE, FLEXIBLE DATA USED     
        - NUMERIC : NUMBER
        - DATETIME : DATE
*/

-- 회원에 대한 데이터를 담기 위한 테이블 MEMBER 생성
CREATE TABLE MEMBER (
  MEM_NO NUMBER,
  MEM_ID VARCHAR2(20),
  MEM_PWD VARCHAR2(20),
  MEM_NAME VARCHAR2(20),
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  CREATE_DATE DATE
);

SELECT * FROM MEMBER;

-- 사용자가 가지고 있는 테이블 정보
-- 데이터 딕셔너리: 다양한 객체들의 정보를 저장하고 있는 시스템; 테이블 등
-- [참고] USER_TABLES: 사용자가 가지고 있는 테이블의 전반적이 구조를 확인 할 수 있는 시스템 테이블
SELECT * FROM USER_TABLES;

-- [참고] USER_TAB_COLUMNS: 사용자가 가지고 있는 테이블의 모든 컬럼의 전반적인 구조를 확인 할 수 있는 시스템 테이블

------------------------------------  
/*
  컬럼에 주석달기
  
  [FORMAT]
    COMMENT ON COLUMN [TALBE_NAME].[COLUMN_NAME] IS 'EXAMPLE';
*/
COMMENT ON COLUMN MEMBER.MEM_NO IS '회원 번호';
COMMENT ON COLUMN MEMBER.MEM_ID IS '회원 아이디';
COMMENT ON COLUMN MEMBER.MEM_PWD IS '회원 비밀번호';
COMMENT ON COLUMN MEMBER.MEM_NAME IS '회원 이름';
COMMENT ON COLUMN MEMBER.GENDER IS '성별(M|F)';
COMMENT ON COLUMN MEMBER.PHONE IS '회원 전화번호';
COMMENT ON COLUMN MEMBER.EMAIL IS '회원 이메일';
COMMENT ON COLUMN MEMBER.CREATE_DATE IS '회원 가입일';

-- 테이블에 데이터를 추가시키는 구문
-- INSERT INTO [TABLE_NAME] VALUES();
INSERT INTO MEMBER VALUES(
  1, 'user01', 'pass01', '홍길동', 'M', '010-1234-5678', 'user01@naver.com', '24/06/01');
INSERT INTO MEMBER VALUES(2, 'user02', 'pass02', '남석천', 'M', NULL, NULL, '24/06/02');
  
SELECT * FROM MEMBER;

------------------------------------  
/*
  데이터 제약 조건
    - 원하는 데이터 값만 유지하기 위해 특정 컬럼에 설정하는 제약
    - 데이터 무결성 보장을 목적으로 함
      : 데이터가 정확하고 유효하게 유지
        1. 개체 무결성 제약 조건 : NOT NULL(NN), UNIQUE, PRIMARY KEY
        2. 참조 무결성 제약 조건 : FOREIGN KEY
  
  종류 : NOT NULL, UNIQUE, PRIMARY KEY, CHECK(조건), FOREIGN KEY
*/

/*
  NOT NULL : 해당 컬럼에는 NULL 데이터가 들어갈 수 없다
  
  제약 조건 방식
    1) 컬럼 레벨 방식 : 컬럼명 자료형 옆에 기술
    2) 테이블 레벨 방식 : 모든 컬럼 작성 후 마지막에 기술
  
  
*/
-- 컬럼 레벨 방식 : NOT NULL
--  NOT NULL 제약조건은 컬럼 방식만 사용 가능
CREATE TABLE MEM_NOTNULL(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  CREATE_DATE DATE
);

SELECT * FROM USER_TABLES;

-- INSERT INTO MEM_NOTNULL VALUES (
--  1, 'user01', NULL, '박고잉', 'F', NULL, 'user01@gmail.com', SYSTIMESTAMP); -- 비밀번호의 NULL값을 허용하지 않음
INSERT INTO MEM_NOTNULL VALUES (
  1, 'user01', 'pass03', '김고잉', 'F', '010-1234-1234', 'user03@gmail.com', SYSTIMESTAMP);
  

/*
  UNIQUE : 해당 컬럼에는 중복된 데이터가 들어갈 수 없다
  
  제약 조건 방식
    1) 컬럼 레벨 방식 : 컬럼명 자료형 옆에 기술
    2) 테이블 레벨 방식 : 모든 컬럼 작성 후 마지막에 기술
  
  
*/
-- 컬럼 레벨 방식 : UNIQUE
CREATE TABLE MEM_UNIQUE(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50)
);


-- 테이블 레벨 방식
CREATE TABLE MEM_UNIQUE2(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  
  UNIQUE(MEM_ID)
);

CREATE TABLE MEM_UNIQUE3(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  
  UNIQUE(MEM_ID), 
  UNIQUE(MEM_NO)
);


CREATE TABLE MEM_UNIQUE4(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  
  UNIQUE(MEM_ID, MEM_NO)
);

INSERT INTO MEM_UNIQUE4 VALUES (
  1, 'user01', 'pass01', '이고잉', 'F', '010-1234-1234', 'user01@gmail.com');
INSERT INTO MEM_UNIQUE4 VALUES (
  2, 'user01', 'pass01', '박고잉', 'F', '010-1234-1234', 'user02@gmail.com');
INSERT INTO MEM_UNIQUE4 VALUES ( -- 성별이 유효한 값이 아니어도 데이터가 저장됨
  3, 'user02', 'pass01', '박고잉', 'A', '010-1234-1234', 'user02@gmail.com');


/*
  CHECK : 해당 컬럼에는 특정 데이터만 들어갈 수 없다
*/
CREATE TABLE MEM_CHECK(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1) CHECK(GENDER IN('F','M')),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50)
);

INSERT INTO MEM_CHECK VALUES(
  1, 'user01', 'pass01', '이고잉', 'F', '010-1234-1234', 'user01@gmail.com');
INSERT INTO MEM_CHECK VALUES(
  2, 'user02', 'pass02', '박고잉', 'A', '010-1234-1234', 'user02@gmail.com');
  
  
CREATE TABLE MEM_CHECK2(
  MEM_NO NUMBER NOT NULL,
  MEM_ID VARCHAR2(20) NOT NULL ,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  UNIQUE(MEM_ID),
  CHECK(GENDER IN('F','M'))
);

/*
  PRIMARY KEY : 테이블에서 각 행을 식별하기 위해 사용하는 컬럼
    기본적으로 NOT NULL + UNIQUE 제약조건을 갖음
    한 테이블에 PK는 하나만 존재함
*/
CREATE TABLE MEM_PRIMARY(
  MEM_NO NUMBER PRIMARY KEY,
  MEM_ID VARCHAR2(20) NOT NULL ,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  UNIQUE(MEM_ID),
  CHECK(GENDER IN('F','M'))
);

CREATE TABLE MEM_PRIMARY2(
  MEM_NO NUMBER,
  MEM_ID VARCHAR2(20) NOT NULL ,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  PRIMARY KEY(MEM_NO),
  UNIQUE(MEM_ID),
  CHECK(GENDER IN('F','M'))
);

INSERT INTO MEM_PRIMARY2 VALUES(1, 'user01', 'pass01','홍길동','M', NULL, NULL);
INSERT INTO MEM_PRIMARY2 VALUES(2, 'user02', 'pass02','남길동','M', NULL, NULL);
INSERT INTO MEM_PRIMARY2 VALUES(2, 'user03', 'pass03','이마재','M', NULL, NULL);

-- 제약조건 이름 변경 : CONSTRAINT [CONST_NAME] [CONST_FORMAT]
CREATE TABLE MEM_PRIMARY3(
  MEM_NO NUMBER,
  MEM_ID VARCHAR2(20) NOT NULL ,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  
  CONSTRAINT MEM_PK PRIMARY KEY(MEM_NO),
  CONSTRAINT UQ_ID UNIQUE(MEM_ID),
  CONSTRAINT CHK_GEN CHECK(GENDER IN('F','M'))
);

-- 복합 키
-- PK를 2개 넣었을 때, 2개를 묶어서 하나의 KEY 역할을 하게 됨
CREATE TABLE MEM_PRIMARY3(
  MEM_NO NUMBER,
  MEM_ID VARCHAR2(20) NOT NULL ,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1),
  PHONE VARCHAR2(13),
  EMAIL VARCHAR2(50),
  
  CONSTRAINT MEM_PK PRIMARY KEY(MEM_NO, MEM_ID),  -- PK 2개를 묶어서 사용
  CONSTRAINT UQ_ID UNIQUE(MEM_ID),
  CONSTRAINT CHK_GEN CHECK(GENDER IN('F','M'))
); 



CREATE TABLE TB_LIKE(
  MEM_NO NUMBER,
  PRODUCT_NAME VARCHAR2(20),
  LIKE_DATE DATE,
  PRIMARY KEY(MEM_NO, PRODUCT_NAME)
);
-- 복합키로 사용한다고 해도 이건 PK 이기 때문에 NN과 UQ 조건을 맞춰줘야함
INSERT INTO TB_LIKE VALUES(1, 'A', SYSDATE);
INSERT INTO TB_LIKE VALUES(1, 'B', SYSDATE);
INSERT INTO TB_LIKE VALUES(2, 'A', SYSDATE);
INSERT INTO TB_LIKE VALUES(2, 'B', SYSDATE);
SELECT * FROM TB_LIKE;
INSERT INTO TB_LIKE VALUES(NULL, 'B', SYSDATE);

--==========================================================================
-- 회원 등급 테이블과 회원 테이블 2개 생성
CREATE TABLE MEM_GRADE(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO MEM_GRADE VALUES(10, '일반회원');
INSERT INTO MEM_GRADE VALUES(20, '우수회원');
INSERT INTO MEM_GRADE VALUES(30, '특별회원');

CREATE TABLE MEM(
  MEM_NO NUMBER CONSTRAINT PK PRIMARY KEY, -- 계정 안에선 제약조건명은 UNIQUE해야함
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1) CHECK(GENDER IN ('M', 'F')),
  GRADE_ID NUMBER
);

INSERT INTO MEM VALUES(1, 'user01', 'pass01',  '홍길동', 'M', 10);
INSERT INTO MEM VALUES(2, 'user02', 'pass02',  '송길동', 'F', 30);
INSERT INTO MEM VALUES(3, 'user03', 'pass03',  '채규태', 'M', 100);


/*
  FOREIGN_KEY
    다른 테이블에 존재하는 값만 들어와야되는 특정 컬럼에 부여하는 제약 조건
    --> 다른 테이블을 참조한다고 표현,
    --> 주로 외래키 제약조건에 의해 테이블 간의 관계가 형성됨
    
    >> COLUMN LEVEL
      COLUMN_NAME DATA_TYPE [CONSTAINT NAME] REFERENCES [TABLE_NAME] [COLUMN NAME]
*/
CREATE TABLE MEM2(
  MEM_NO NUMBER PRIMARY KEY,
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1) CHECK(GENDER IN ('M', 'F')),
  GRADE_ID NUMBER REFERENCES MEM_GRADE(GRADE_CODE) -- NOT NULL (NULL을 제외하고 싶을때)
--  FOREIGN KEY(GRADE_ID) REFERENCES MEM_GRADE(GRADE_CODE)
);

INSERT INTO MEM2 VALUES(1, 'user01', 'pass01',  '홍길동', 'M', 10);
INSERT INTO MEM2 VALUES(2, 'user02', 'pass02',  '송길동', 'F', 30);
INSERT INTO MEM2 VALUES(3, 'user03', 'pass03',  '채규태', 'M', 100);
-- 외래키 제약조건 위배
-- MEM_GRADE(부모 테이블) -|-----<--- MEM2(자식테이블)
INSERT INTO MEM2 VALUES(3, 'user03', 'pass03',  '채규태', 'M', NULL);
-- 외래키는 기본적으로 NULL 허용

--> 이 때 부모테이블에서 데이터값을 삭제할 경우 문제 발생
-- 데이터 삭제 : DELETE FROM [TABLE_NAME] WHERE [CASE]
DELETE FROM MEM_GRADE
WHERE GRADE_CODE = 20;
-- 자식 테이블에서 사용하지 않는 데이터를 포함한 행은 삭제 가능
DELETE FROM MEM_GRADE
WHERE GRADE_CODE = 10;
-- 자식 테이블에서 사용중인 데이터는 삭제 불가


/*
  자식 테입르 생성 시 외래키 제약조건 부여할 때 삭제옵션 지정 가능
    - 삭제 옵션 : 부모테이블의 데이터 삭제 시 자식테이블이 사용하고 있는 값을 어떻게 처리할지
    
    1) ON DELETE RESTRICTED(기본값) : 삭제 제한
    2) ON DELETE SET NULL : 부모테이블의 데이터 삭제 시 자식테이블이 쓰고 있는 값들을 NULL로 변경하고 부모테이블의 값을 NULL로 변경
    3) ON DELETE CASCADE : 부모테이블의 데이터 삭제 시 자식테이블이 쓰고 있는 행도 삭제
*/

-- 외래키 생성 시 참조 테이블명만 넣으면 참조테이블의 기본키의 컬럼이 자동으로 설정됨

CREATE TABLE MEM(
  MEM_NO NUMBER PRIMARY KEY,
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1) CHECK(GENDER IN ('M', 'F')),
  GRADE_ID NUMBER REFERENCES MEM_GRADE ON DELETE SET NULL
);

INSERT INTO MEM VALUES(1, 'user01', 'pass01', '이고잉', 'F', 10);
INSERT INTO MEM VALUES(2, 'user02', 'pass02', '이고잉', 'M', 30);
INSERT INTO MEM VALUES(3, 'user03', 'pass03', '이고잉', 'F', 20);
INSERT INTO MEM VALUES(4, 'user04', 'pass04', '이고잉', 'M', NULL);

delete from mem_grade where grade_code = 30;

DROP TABLE MEM;

CREATE TABLE MEM(
  MEM_NO NUMBER PRIMARY KEY,
  MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
  MEM_PWD VARCHAR2(20) NOT NULL,
  MEM_NAME VARCHAR2(20) NOT NULL,
  GENDER CHAR(1) CHECK(GENDER IN ('M', 'F')),
  GRADE_ID NUMBER REFERENCES MEM_GRADE ON DELETE CASCADE
);

INSERT INTO MEM VALUES(1, 'user01', 'pass01', '이고잉', 'F', 10);
INSERT INTO MEM VALUES(2, 'user02', 'pass02', '이고잉', 'M', 30);
INSERT INTO MEM VALUES(3, 'user03', 'pass03', '이고잉', 'F', 20);
INSERT INTO MEM VALUES(4, 'user04', 'pass04', '이고잉', 'M', NULL);

DELETE FROM MEM_GRADE WHERE GRADE_CODE = 30;
SELECT * FROM MEM;

---------------------------------------------------------------------------------
/*
  DEFAULT
    컬럼의 값이 들어오지 않았을 때 기본값으로 지정해주는 구문
    
  [FORMAT]
    COLUMN_NAME DATA_TYPE DEFAULT (DEF_VALUE) [CONSTRAINTMENT]
*/
CREATE TABLE MEMBER2(
  MEM_NO NUMBER PRIMARY KEY,
  MEM_ID VARCHAR2(20) NOT NULL,
  MEM_AGE NUMBER,
  HOBBY VARCHAR2(20) DEFAULT '없음',
  MEM_DATE DATE DEFAULT SYSDATE
);

INSERT INTO MEMBER2 VALUES (1, 'user01', 25, '잠자기', '24/06/13');
INSERT INTO MEMBER2 VALUES (2, 'user02', NULL, NULL, NULL);
INSERT INTO MEMBER2 VALUES (3, 'user03', 27, DEFAULT, DEFAULT);
INSERT INTO MEMBER2 (MEM_NO, MEM_ID, MEM_AGE) VALUES (4, 'user04', 22);

SELECT * FROM MEMBER2;

--=============================================================================================
/*
  SUBQUERY를 이용한 테이블 생성
    테이블 복사하는 개념
    
    [FORMAT]
    CREATE TABLE [TABLE_NAME] AS (SUBQUERY);
*/

CREATE TABLE EMPLOYEE_COPY 
AS (SELECT * 
    FROM EMPLOYEE);
    
CREATE TABLE EMPLOYEE_COPY2
AS SELECT *
    FROM EMPLOYEE
    WHERE 1 = 0;

SELECT * FROM EMPLOYEE_COPY2;

CREATE TABLE EMPLOYEE_COPY3
AS SELECT EMP_ID, EMP_NAME, SALARY
    FROM EMPLOYEE
    WHERE 1 = 0;

CREATE TABLE EMPLOYEE_COPY4
AS SELECT EMP_ID, EMP_NAME, SALARY, SALARY*12 연봉
    FROM EMPLOYEE;
    
SELECT * FROM EMPLOYEE_COPY3;

DROP TABLE EMPLOYEE_COPY3;
DROP TABLE EMPLOYEE_COPY4;


-------------------------------------------------------------------------------------------------
/*
  테이블 생성 후 제약조건 추가
  ALTER TABLE [TABLE_NAME] [CHANGES]
    PK : ALTER TABLE [TABLE_NAME] ADD PRIMARY KEY([COLUMN_NAME])
    FK : ALTER TABLE [TABLE_NAME] ADD FOREIGN KEY([MY_COLUMN_NAME) REFERENCES [TABLE_NAME]([COLUMN_NAME])
    UQ : ALTER TABLE [TABLE_NAME] ADD UNIQUE(COLUMN_NAME)
    CK : ALTER TABLE [TABLE_NAME] ADD CHECK(RULE_FOR_COLUMN)
    NN : ALTER TABLE [TABLE_NAME] MODIFY [COLUMN_NAME] NOT NULL
*/
-- EMPLOYEE_COPY 테이블에 PK 추가
ALTER TABLE EMPLOYEE_COPY ADD PRIMAL KEY(EMP_ID);
-- EMPLOYEE_COPY 테이블에 외래키 제약 추가
ALTER TABLE EMPLOYEE_COPY ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
-- COMMENT
COMMENT ON COLUMN EMPLOYEE_COPY.EMP_ID IS '사원 아이디';


----------------------------------------------------- 연습문제 ---------------------------------------------------
--  DDL 계정에서
/*
도서관리 프로그램을 만들기 위한 테이블들 만들기
이때, 제약조건에 이름을 부여할 것.
       각 컬럼에 주석달기

1. 출판사들에 대한 데이터를 담기위한 출판사 테이블(TB_PUBLISHER)
   컬럼  :  PUB_NO(출판사번호) NUMBER -- 기본키(PUBLISHER_PK) 
	PUB_NAME(출판사명) VARCHAR2(50) -- NOT NULL(PUBLISHER_NN)
	PHONE(출판사전화번호) VARCHAR2(13) - 제약조건 없음

   - 3개 정도의 샘플 데이터 추가하기
*/
CREATE TABLE TB_PUBLISHER(
  PUB_NO NUMBER,
  PUB_NAME VARCHAR2(50) CONSTRAINT PUBLISHER_NN NOT NULL,
  PHONE VARCHAR2(13),
  
  CONSTRAINT PUBLISHER_PK PRIMARY KEY(PUB_NO)
);

COMMENT ON COLUMN TB_PUBLISHER.PUB_NO IS '출판사번호';
COMMENT ON COLUMN TB_PUBLISHER.PUB_NAME IS '출판사명';
COMMENT ON COLUMN TB_PUBLISHER.PHONE IS '출판사전화번호';

INSERT INTO TB_PUBLISHER VALUES(1, '대한출판사', '02)743-3324');
INSERT INTO TB_PUBLISHER VALUES(2, '민국출판사', '02)743-6657');
INSERT INTO TB_PUBLISHER VALUES(3, '만세출판사', '02)743-9980');

/*
2. 도서들에 대한 데이터를 담기위한 도서 테이블(TB_BOOK)
   컬럼  :  BK_NO (도서번호) NUMBER -- 기본키(BOOK_PK)
	BK_TITLE (도서명) VARCHAR2(50) -- NOT NULL(BOOK_NN_TITLE)
	BK_AUTHOR(저자명) VARCHAR2(20) -- NOT NULL(BOOK_NN_AUTHOR)
	BK_PRICE(가격) NUMBER
	BK_PUB_NO(출판사번호) NUMBER -- 외래키(BOOK_FK) (TB_PUBLISHER 테이블을 참조하도록)
			         이때 참조하고 있는 부모데이터 삭제 시 자식 데이터도 삭제 되도록 옵션 지정
   - 5개 정도의 샘플 데이터 추가하기
*/
CREATE TABLE TB_BOOK(
  BK_NO NUMBER,
  BK_TITLE VARCHAR2(50) CONSTRAINT BOOK_NN_TITLE NOT NULL,
  BK_AUTHOR VARCHAR2(20) CONSTRAINT BOOK_NN_AUTHOR NOT NULL,
  BK_PRICE NUMBER,
  BK_PUB_NO NUMBER,
  
  CONSTRAINT BOOK_PK PRIMARY KEY(BK_NO),
  CONSTRAINT BOOK_FK FOREIGN KEY(BK_PUB_NO) REFERENCES TB_PUBLISHER(PUB_NO) ON DELETE CASCADE
);

COMMENT ON COLUMN TB_BOOK.BK_NO IS '도서번호';
COMMENT ON COLUMN TB_BOOK.BK_TITLE IS '도서명';
COMMENT ON COLUMN TB_BOOK.BK_AUTHOR IS '저자명';
COMMENT ON COLUMN TB_BOOK.BK_PRICE IS '가격';
COMMENT ON COLUMN TB_BOOK.BK_PUB_NO IS '출판사 번호';

INSERT INTO TB_BOOK VALUES(1 , 'A', 'AA', 4000, 1);
INSERT INTO TB_BOOK VALUES(2 , 'B', 'BB', 4000, 2);
INSERT INTO TB_BOOK VALUES(3 , 'C', 'CC', 4000, 2);
INSERT INTO TB_BOOK VALUES(4 , 'D', 'DD', 4000, 3);
INSERT INTO TB_BOOK VALUES(5 , 'E', 'EE', 4000, 1);;

/*
3. 회원에 대한 데이터를 담기위한 회원 테이블 (TB_MEMBER)
   컬럼명 : MEMBER_NO(회원번호) NUMBER -- 기본키(MEMBER_PK)
   MEMBER_ID(아이디) VARCHAR2(30) -- 중복금지(MEMBER_UQ)
   MEMBER_PWD(비밀번호)  VARCHAR2(30) -- NOT NULL(MEMBER_NN_PWD)
   MEMBER_NAME(회원명) VARCHAR2(20) -- NOT NULL(MEMBER_NN_NAME)
   GENDER(성별)  CHAR(1)-- 'M' 또는 'F'로 입력되도록 제한(MEMBER_CK_GEN)
   ADDRESS(주소) VARCHAR2(70)
   PHONE(연락처) VARCHAR2(13)
   STATUS(탈퇴여부) CHAR(1) - 기본값으로 'N' 으로 지정, 그리고 'Y' 혹은 'N'으로만 입력되도록 제약조건(MEMBER_CK_STA)
   ENROLL_DATE(가입일) DATE -- 기본값으로 SYSDATE, NOT NULL 제약조건(MEMBER_NN_EN)

   - 5개 정도의 샘플 데이터 추가하기
*/

CREATE TABLE TB_MEMBER(
  MEMBER_NO NUMBER CONSTRAINT MEMBER_PK PRIMARY KEY,
  MEMBER_ID VARCHAR2(30) CONSTRAINT MEMBER_UQ UNIQUE NOT NULL,
  MEMBER_PWD VARCHAR2(30) CONSTRAINT MEMBER_NN_PWD NOT NULL,
  MEMBER_NAME VARCHAR2(30) CONSTRAINT MEMBER_NN_NAME NOT NULL,
  GENDER CHAR(1) CONSTRAINT MEMBER_CK_GEN CHECK (GENDER IN ('M', 'F')),
  ADDRESS VARCHAR2(70),
  PHONE VARCHAR2(13),
  STATUS CHAR(1) DEFAULT 'N' CONSTRAINT MEMBER_CK_STA CHECK (STATUS IN ('N', 'Y')),
  ENROLL_DATE DATE DEFAULT SYSDATE CONSTRAINT MEMBER_NN_EN NOT NULL
);

COMMENT ON COLUMN TB_MEMBER.MEMBER_NO IS '회원번호';
COMMENT ON COLUMN TB_MEMBER.MEMBER_ID IS '아이디';
COMMENT ON COLUMN TB_MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN TB_MEMBER.MEMBER_NAME IS '회원명';
COMMENT ON COLUMN TB_MEMBER.GENDER IS '성별';
COMMENT ON COLUMN TB_MEMBER.ADDRESS IS '주소';
COMMENT ON COLUMN TB_MEMBER.PHONE IS '연락처';
COMMENT ON COLUMN TB_MEMBER.STATUS IS '탈퇴여부';
COMMENT ON COLUMN TB_MEMBER.ENROLL_DATE IS '가입일';

INSERT INTO TB_MEMBER VALUES(1, 'user01', 'pass01', '1길동', 'M', 'user01@google.com', '010-1234-1234', 'N', DEFAULT);
INSERT INTO TB_MEMBER VALUES(2, 'user02', 'pass01', '2길동', 'M', 'user02@google.com', '010-2345-2345', 'N', DEFAULT);
INSERT INTO TB_MEMBER VALUES(3, 'user03', 'pass01', '3길동', 'M', 'user03@google.com', '010-3456-3456', 'N', DEFAULT);
INSERT INTO TB_MEMBER VALUES(4, 'user04', 'pass01', '4길동', 'M', 'user04@google.com', '010-4567-4567', 'Y', DEFAULT);
INSERT INTO TB_MEMBER VALUES(5, 'user05', 'pass01', '5길동', 'M', 'user05@google.com', '010-5678-5678', 'N', DEFAULT);

/*
4. 어떤 회원이 어떤 도서를 대여했는지에 대한 대여목록 테이블(TB_RENT)
   컬럼  :  RENT_NO(대여번호) NUMBER -- 기본키(RENT_PK)
	RENT_MEM_NO(대여회원번호) NUMBER -- 외래키(RENT_FK_MEM) TB_MEMBER와 참조하도록
			이때 부모 데이터 삭제시 자식 데이터 값이 NULL이 되도록 옵션 설정
	RENT_BOOK_NO(대여도서번호) NUMBER -- 외래키(RENT_FK_BOOK) TB_BOOK와 참조하도록
			이때 부모 데이터 삭제시 자식 데이터 값이 NULL값이 되도록 옵션 설정
	RENT_DATE(대여일) DATE -- 기본값 SYSDATE

   - 3개 정도 샘플데이터 추가하기
*/
CREATE TABLE TB_RENT(
  RENT_NO NUMBER CONSTRAINT RENT_PK PRIMARY KEY,
  RENT_MEM_NO NUMBER, 
  RENT_BOOK_NO NUMBER,
  RENT_DATE DATE DEFAULT SYSDATE,
  
  CONSTRAINT RENT_FK_MEM FOREIGN KEY(RENT_MEM_NO) REFERENCES TB_MEMBER(MEMBER_NO) ON DELETE SET NULL,
  CONSTRAINT RENT_FK_BOOK FOREIGN KEY(RENT_BOOK_NO) REFERENCES TB_BOOK(BK_NO) ON DELETE SET NULL
);

COMMENT ON COLUMN TB_RENT.RENT_NO IS '대여번호';
COMMENT ON COLUMN TB_RENT.RENT_MEM_NO IS '대여회원번호';
COMMENT ON COLUMN TB_RENT.RENT_BOOK_NO IS '대여도서번호';
COMMENT ON COLUMN TB_RENT.RENT_DATE IS '대여일';
  